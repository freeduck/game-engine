#lang racket

(require rackunit 
         "../main.rkt"
         "./util.rkt")

(require threading)


(define-component conway (x y alive?))          

(define (die c)  (set-conway-alive? c #f))
(define (live c) (set-conway-alive? c #t))

(define/contract (entity-xy=? x y)
                 (-> number? number?
                     (-> entity? boolean?))

                 (lambda (e)
                   (define my-x (entity-conway-x e))  
                   (define my-y (entity-conway-y e))  

                   (and 
                     (= my-x x)
                     (= my-y y))))

(define/contract (neighbor dx dy)
                 (-> number? number? (-> game? entity? (or/c entity? #f)))

                 (lambda (g e)
                   (define my-x (entity-conway-x e))
                   (define my-y (entity-conway-y e))
                   (get-entity* g
                                (entity-xy=? (+ my-x dx)
                                             (+ my-y dy)))))

(define north      (neighbor  0 -1))
(define south      (neighbor  0  1))
(define east       (neighbor  1  0))
(define west       (neighbor -1  0))
(define north-west (neighbor -1 -1))
(define north-east (neighbor  1 -1))
(define south-west (neighbor -1  1))
(define south-east (neighbor  1  1))

(define (live-neighbors g e)
  (filter entity-conway-alive? 
          (filter identity
                  (list (north g e)
                        (south g e)
                        (west g e)
                        (east g e)
                        (north-east g e)
                        (north-west g e)
                        (south-east g e)
                        (south-west g e))))) 

(define (conway-update g e c)
  (define n (length (live-neighbors g e)))
  (displayln n)
  (displayln c)

  (define ret (cond 
                [(and (conway-alive? c)
                      (< n 2))
                 (die c)]
                [(and (conway-alive? c)
                      (or (= n 2) (= n 3)))
                 (live c)]
                [(and (conway-alive? c)
                      (> n 3))
                 (die c)]
                [(and (not (conway-alive? c))
                      (= n 3))
                 (live c)]
                [else c]))


  (displayln ret)

  ret)

(define (conway-game size)
  (define es 
    (for*/list ([y (range size)]
                [x (range size)])
      (entity (conway x y #f #:update conway-update))))

  (apply game es))

(define (conway-game-set g x y alive?)
  (update-entity* g
                  (entity-xy=? x y)

                  ;TODO: Gotta figure out what convenience functions (if any) return handlers, and which return more normal functions...
                  (lambda (e)
                    (update-component* e conway?
                                       (curryr set-conway-alive? alive?)))))


(define g0 (~> (conway-game 3)
               (conway-game-set _ 0 0 #t)
               (conway-game-set _ 1 0 #t)
               (conway-game-set _ 2 0 #t)
               (conway-game-set _ 0 1 #t)
               (conway-game-set _ 1 1 #t)
               (conway-game-set _ 2 1 #t)
               (conway-game-set _ 0 2 #t)
               (conway-game-set _ 1 2 #t)
               (conway-game-set _ 2 2 #t)))

(define (conway-print g)
  ;TODO: Generalize to bigger grids

  (define es (game-entities g))  

  (define row1 (take es 3))
  (define row2 (take (drop es 3) 3))
  (define row3 (take (drop es 6) 3))

  (displayln (map entity-conway-alive? row1))
  (displayln (map entity-conway-alive? row2))
  (displayln (map entity-conway-alive? row3))) 



(test-case "Conway's game of life"

           (define gs (tick-list g0 3))

           (for ([g gs]
                 [i (in-naturals)])
             (displayln i) 
             (conway-print g))

           (check-true
             (all-alive (first gs)))
           (check-true
             (all-dead (third gs)))


           ()



           )





